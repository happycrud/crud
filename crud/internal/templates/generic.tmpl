// Code generated by crud. DO NOT EDIT.

package {{.PackageName}}

import (
{{if .ImportTime}}
	"time"
{{end}}
    "github.com/happycrud/crud/xsql"
	"github.com/happycrud/crud/xsql/dialect"
)

{{ $table := .}}

type {{.GoTableName}} struct {
	{{- range .Fields }}
    	{{ .GoColumnName }} {{  .GoColumnType }} `json:"{{ .ColumnName }}"` // {{ .ColumnComment }}
    {{- end}}
}

const (
    // table tableName is {{.TableName}}
    table = "{{.TableName}}"
    {{- range .Fields}}
        //{{.GoColumnName }} {{.ColumnComment}}
        {{ .GoColumnName}} = "{{.ColumnName}}"  
    {{- end }}
)

var columns = []string{
	{{- range .Fields}}
    {{ .GoColumnName}},
    {{- end }}
}


var columnsSet = map[string]struct{}{
	{{- range .Fields}}
    {{ .GoColumnName}}:{},
    {{- end }}
}

func Columns() []string{
    return columns
}
func ColumnsSet() map[string]struct{} {
	return columnsSet
}


func (a *{{.GoTableName}}) NewPtr() any {
	return &{{.GoTableName}}{}
}
func (a *{{.GoTableName}}) IsNil() bool {
	return a == nil
}

func (u *{{.GoTableName}}) ScanDst(aa any, columns []string) []any {
	if a, ok := aa.(*{{.GoTableName}}); ok {
		dst := make([]interface{}, 0, len(columns))
		for _, v := range columns {
			switch v {
			{{- range .Fields}}
   			case {{.GoColumnName}}:
			dst = append(dst, &a.{{.GoColumnName}})
    		{{- end }}
		}
		}
		return dst
	}
	return []any{}

}

func (a *{{.GoTableName}}) Values() []any {
	if a.IsNil() {
		return []any{}
	}
	return []interface{}{ {{ sqltool .  "goinfieldcolbulk"}} }
}
func (a *{{.GoTableName}}) GetAutoIncrPk()  (int64,string) {
	if a.IsNil() {
		return 0,{{.PrimaryKey.GoColumnName}}
	}
	return a.{{.PrimaryKey.GoColumnName}},{{.PrimaryKey.GoColumnName}}
}
func (a *{{.GoTableName}}) SetAutoIncrPk(id int64) {
	if a.IsNil() {
		return
	}
	a.{{.PrimaryKey.GoColumnName}} = {{.PrimaryKey.GoColumnType}}(id)
}

func (a *{{.GoTableName}}) Columns() []string {
	return columns
}
func (a *{{.GoTableName}}) ColumnsSet() map[string]struct{} {
	return columnsSet
}

func (a *User)Dialect()string{
	 {{$ismysql :=  eq .Dialect "mysql"}}
	 {{$ispg :=  eq .Dialect "postgres"}}
	 {{$issqlite :=  eq .Dialect "sqlite3"}}
	 {{if $ismysql}}{{end}}
	return  {{if $ismysql}}dialect.MySQL{{end}} {{if $ispg}}dialect.Postgres{{end}} {{if $issqlite}}dialect.SQLite{{end}}
}
func(a *User)Table()string{
	return table
}


{{- range .GenerateWhereCol }}
		{{$c1:=gt .BigType 0}}
		{{if $c1}}
			{{GoTypeToWhereFunc .GoColumnType .GoColumnName}}	
		{{end}}
		
{{- end}}

func And(predicates ...xsql.WhereFunc) xsql.WhereFunc {
	return xsql.AndOp(predicates...)
}
func Or(predicates ...xsql.WhereFunc) xsql.WhereFunc {
	return xsql.OrOp(predicates...)
}
func Not(predicate xsql.WhereFunc) xsql.WhereFunc {
	return xsql.NotOp(predicate)
}

func Create(db xsql.ExecQuerier) *Creater {
	return &Creater{xsql.NewInsertExecutor[*{{.GoTableName}}](db)}
}

type Creater struct{
	*xsql.InsertExecutor[*{{.GoTableName}}]
}

func (c *Creater) Set{{.GoTableName}}(a ...*{{.GoTableName}}) *Creater {
	c.SetItems(a...)
	return c
}

func Find(db xsql.ExecQuerier) *xsql.SelectExecutor[*{{.GoTableName}}] {
	return xsql.NewSelectExecutor[*{{.GoTableName}}](db)
}
func Delete(db xsql.ExecQuerier) *xsql.DeleteExecutor[*{{.GoTableName}}] {
	return xsql.NewDeleteExecutor[*{{.GoTableName}}](db)
}
func Update(db xsql.ExecQuerier) *Updater {
	return &Updater{xsql.NewUpdateExecutor[*{{.GoTableName}}](db)}
}

type Updater struct {
	*xsql.UpdateExecutor[*{{.GoTableName}}]
}

{{ range .Fields }}
	func (u *Updater) Set{{ .GoColumnName }} (arg {{  .GoColumnType }}) *Updater {
		u.Set({{ .GoColumnName }} , arg)
		return u
	}
	{{$c3:=eq .BigType 1}}
	{{$c4:=not .IsPrimaryKey}}
	{{if and $c3 $c4}}
		{{if isnumber .GoColumnType}}
			func (u *Updater) Add{{ .GoColumnName }} (arg  interface{}) *Updater {
				u.Add({{ .GoColumnName }} , arg)
				return u
			}
		{{end}}
	{{end}}
{{ end }}
